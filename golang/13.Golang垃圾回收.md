# Golang 垃圾回收

## 三色标记清除

1. 初始对象都是白色的，遍历根节点集合
2. 从根部向下遍历扫描，把遍历到引用的对象放入灰色集合
3. 遍历灰色集合，如果有引用的对象将引用的对象放入灰色集合
4. 无论有没有引用的对象都会将自己升级到黑色集合里
5. 重复 3 和 4 直到灰色集合中无任何对象
6. 清除白色的对象

这个过程类似**逐层打印二叉树**

## 问题来了？

* 如果没有 STW，当灰色下的白色被黑色引用后又被灰色解除了引用时，这个白色的就会被错误清除掉

## 那怎么办？

> 写屏障！

##### 强三色不变式

> 插入屏障

Goal: 不存在黑色对象引用到白色对象的指针
How: 在 A 对象引用 B 对象的时候，B 对象被标记为灰色

##### 弱三色不变式

> 删除屏障

Goal: 将被删除节点下游的对象在这一轮保存以防止误伤
How: 被删除的对象，如果自身为白色，那么被标记为灰色

## 栈上的变化快用写屏障他不划算啊

* 堆上**写屏障**，开启 STW，栈上三色标记，关闭 STW，清除垃圾

### 还是不满意？

> 混合写屏障

1. GC 开始扫描栈区将可达对象全部标记为黑
2. GC 期间任何在栈上创建的新对象均为黑色
4. 堆上被添加的对象标记为灰色{插入屏障}
5. 堆上被删除的对象标记为灰色{删除屏障}

* 简单说就是开始 GC 时保障栈上的对象完整
* 直接免除了堆上对象操作栈上对象的顾虑
* 几乎不用 STW，效率杠杠的

## Reference

* https://www.jianshu.com/p/4c5a303af470