![avatar](http://pythonup.cn/static/public/picture/133.png)

# Golang 协程调度

> 要深度没有, 白话倒是很多

### 大白话

* 有的程序中有系统调用，第三方调用等这些耗时操作
* 一直等么？占着茅坑不拉屎？时间就是金钱
* 请打包好你的东西去一边等一会，把自己的事情处理好再过来 [ 上下文切换 ]
* 不管多进程还是多线程，fork 时会发生系统调用，开销大
* 那么我 CPU 有几个核就起几个线程待命，就像 php-fpm 一样 [ 线程池 ]
* 多个协程其实就在这几个线程上，运行、等待、切换
* 对比多线程上下文切换频繁地在用户态和内核态来回的切换，协程只是在用户态切换
* 有几个窗口 [ m ] 就有几个柜员，有几个柜员就排几个队 [ p ]，办事儿的 [ g ] 该排队排队
* 这样就充分利用了 CPU 的时间，一刻也不能让丫歇着
* 发热？我给你放海里~ [ 微软如是说 ]

### 线程模型

> N : 1

N 个用户协程运行在1个内核线程中，无法利用多核的算力

> 1 : 1

每个用户协程对应一个内核线程，这就是线程池了，没协程啥事儿

> M : N

上边两种的混合体，M 个用户协程运行在N个内核线程中，复杂就复杂点，香就好了

### GMP

> 有三个基础的结构体来实现 goroutines 的调度。g，m，p。

* `g` 代表一个 goroutine，每个 go 关键字都会创建一个协程
* `m` 表示内核线程，包含正在运行的 goroutine 等字段。[ 线程池 ] 
* `p` 代表一个虚拟的 Processor，它维护一个处于 Runnable 状态的 `g` 队列，`m` 需要获得 `p` 才能运行 `g`
* `m` 的个数通常稍大于 `p` 的数量，处理一些 go 代码之外的任务
* `p` 的数量一般等于 CPU 的核心数量

### 工作量窃取

* 当协程产生子协程，这个子协程又贡献了孙子，子子孙孙无穷尽
* 那么各个 `p` 上的任务其实不是均匀的
* 某个 `p` 闲的没 p 事时就会去跟其他 `p` 分摊任务