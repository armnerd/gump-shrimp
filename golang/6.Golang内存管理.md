![avatar](http://pythonup.cn/static/public/picture/132.jpeg)

# Golang 内存管理

> 深挖原理之蜻蜓点水

## 堆与栈

* 栈由 Go 的运行时负责，不开放给用户态代码，一般来说就是函数调用及返回时局部变量所存在的地方
* 堆由 Go 用户态代码所使用，负责了用户态对象的存放以及 goroutine 的执行栈，也是需要垃圾回收的地方

## 逃逸分析

* 函数返回指针的，闭包引用局部变量的，涉及的变量会储存在堆上而不是栈上
* 变量太大栈上放不下的也会放在堆上
* 当形参为 interface 类型时，在编译阶段编译器无法确定其具体的类型。因此会产生逃逸，最终分配到堆上。常见的情况有 fmt.Println(str)

> How to observe

```bash
// 编译器命令
go build -gcflags '-m -l' main.go

// 反编译命令
go tool compile -S main.go
```

## 组成结构

* 预申请的内存划分为 spans、bitmap、arena 三部分
* spans 和 bitmap 是为了管理 arena 存在的
* arena 即所谓的堆区，由页组成
* 页是向操作系统申请内存的最小单位，目前设计为 8KB
* mspan 是 mheap 上管理的一连串的页
* 层次关系：mheap > mcentral > mcache
* 当 mcache 中 span 的数量不够使用时，会向 mcentral 的 nonempty 列表中获得新的 span
* 当 mcentral 中 nonempty 列表中也没有可分配的 span 时，则会向 mheap 提出请求，从而获得新的 span，并进而交给 mcache
* mcache 是为每个线程提供的一小块私有内存，而 mcentral 是全局的

## 垃圾回收

> 垃圾回收中的垃圾就是堆上没有被引用的变量，这种情况也叫做内存泄露

### 0. 常见的 GC 实现

> 追踪式

从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象

> 引用计数式

每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用

> 分代式

将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。Java 就是这样的，能站的绝对不坐的，怎么复杂怎么来

### 1. 根对象

> 根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象

* 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
* 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
* 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块

### 2. 标记清扫法

* 标记追踪：从根集合（寄存器、执行栈、全局变量）开始遍历对象图，标记遇到的每个对象
* 清扫回收：检查堆中每一个对象，将所有未标记的对象当做垃圾进行回收

### 3. 三色抽象

* 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
* 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
* 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

### 4. 写屏障

> STW / Stop the World / 按下暂停键，等我先搞完的

* 一轮一轮来，别非要一次搞定